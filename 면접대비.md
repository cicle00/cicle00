## 데이터베이스 기본

### Q: 릴레이션과 관계의 차이점은 무엇인가요?
릴레이션은 데이터베이스에서 데이터를 테이블 형태로 저장하는 기본 단위이며, 관계는 서로 다른 릴레이션 간의 연관성을 의미합니다.   

### Q: 기본 키와 후보 키의 차이점은 무엇인가요?
기본키는 테이블에서 각 행을 고유하게 식별하는 키이며, 반드시 하나만 존재해야 하고 NULL 값을 가질 수 없습니다.     
후보키는 기본키가 될 수 있는 속성들의 후보들로, 여러 개가 존재할 수 있지만 그중 하나만 기본 키로 선택됩니다.

### Q: Key의 종류와 특징에 대해 간단히 설명해보세요.
키는 테이블에서 데이터를 고유하게 식별하는 역할을 합니다.    
먼저 기본 키는 각 행을 유일하게 식별하는 키로, NULL과 중복을 허용하지 않습니다.   
후보 키는 기본 키로 선택될 수 있는 후보로, 그중 하나만 기본 키로 선택됩니다.   
외래 키는 다른 테이블의 기본 키를 참조하는 키로, 테이블 간의 관계를 설정하는 데 사용됩니다.   
대체 키는 후보 키 중에서 기본 키로 선택되지 않은 키입니다.   
슈퍼 키는 한 개 이상의 속성 조합으로 각 행을 고유하게 식별할 수 있지만 최소성을 충족하지 않는 키입니다.    

***

## ERD와 정규화

### Q. ERD는 무엇이며, 왜 중요한가요?
ERD는 데이터베이스의 구조를 시각적으로 표현하는 다이어그램입니다.   
엔터티, 속성, 관계를 도식화하여 데이터의 흐름과 관계를 한눈에 파악할 수 있게 도와줍니다.   
이를 통해 개발자가 데이터 구조를 직관적으로 이해하고, 일관된 설계를 유지하는 데 도움을 주어   
비즈니스 로직을 명확하게 정리할 수 있습니다.   

### Q. 그렇다면 ERD를 설계할 때 고려해야 할 요소는 무엇인가요?
ERD를 설계할 때는 데이터 무결성과 성능을 고려하여 테이블과 관계를 정의해야 합니다.   
시스템에서 어떤 객체(명사)를 테이블로 관리할지 결정하고, 각 엔터티가 어떤 정보를 저장해야 하는지 속성을 설정해야 합니다.   
키본키를 설정하고, 정규화를 고려해 데이터 중복을 최소화하며 효율적인 구조로 설계해야 합니다.    
그리고 릴레이션 간의 관계를 적절하게 정의하고 연결해야 합니다.   
무결성과 성능을 종합적으로 고려해 ERD를 설계해야 합니다.   

### Q. ERD를 먼저 설계하고 Entity를 개발하면 어떤 점이 도움이 되나요?
ERD를 먼저 설계하면 데이터 구조를 체계적으로 정리하고, 논리적인 데이터 흐름을 검토할 수 있습니다.   
개발자 간의 데이터 구조 해석 차이를 줄여 일관된 모델을 유지할 수 있고, 잘못된 종속 관계를 방지하여 이상현상을 줄일 수 있습니다.   
또한 데이터 모델링에 대한 논의가 줄어들고 개발이 원활해지고, 확장과 유지보수에 도움이 됩니다.   
따라서 ERD를 먼저 설계하면 데이터베이스 품질이 향상되고, 개발 효율성을 높일 수 있습니다.   

### Q. 정규화에 대해 설명해주세요. 정규화의 단점은 무엇인가요?
정규화는 잘못된 종속 관계로 인한 데이터 이상현상을 해결하고, 중복을 줄여 데이터 무결성을 유지하는 과정입니다.   
정규화의 단점으로는 먼저 성능 저하가 있습니다.   
정규화로 인해 테이블이 많아지면서 조인이 증가하여 성능이 저하될 수 있습니다. 특히 트랜잭션이 많은 경우 처리속도가 느려질 수 있습니다.   
그리고 너무 세분화된 테이블 구조로 인해 복잡성이 증가할 수 있습니다.    
따라서 정규화는 성능을 고려하여 적절히 적용해야 합니다.   

### Q. 정규화의 단점으로 미루어보았을 때, 어떤 상황에서 정규화를 진행해야 할까요? 단점에 대한 대응책은?
정규화는 데이터 중복이 많이 갱신 이상이 발생할 가능성이 클 때, 무결성이 최우선으로 중요한 시스템일 경우, 그리고 데이터 저장 공간을 최적화해야 하는 경우에 정규화가 필요합니다.   
그리고 정규화의 단점에 대한 대응책으로는 일부 테이블을 통합하는 반정규화 과정으로 조인을 줄일 수 있습니다.   
또한 인덱스를 활용해 조회 성능을 개선하고 파티셔닝을 통해 대량의 데이터를 분산하여 성능을 개선할 수 있습니다.   
이렇게 정규화와 반정규화를 활용하여 시스템 성능과 데이터 무결성 사이에서 균형을 유지해야 합니다.   

***

## 트랜잭션과 무결성
### Q. 트랜잭션에 대해 설명해주세요. 그리고 왜 사용해야 하나요?
트랜잭션은 데이터베이스에서 하나의 논리적인 작업 단위입니다. 여러 개의 SQL 연산을 하나로 묶어 실행하며, 트랜잭션 내의 모든 작업이 성공해야만 최종적으로 적용됩니다. 만약 중간에 하나라도 실패하면 전체를 취소하여 이전 상태로 되돌릴 수 있습니다.   
트랜잭션을 사용하는 이유는 데이터의 무결성을 유지하고, 오류 발생 시 데이터를 복구하며, 동시에 여러 사용자가 데이터베이스를 사용할 때 일관성을 보장하기 위해서입니다.    

### Q. ACID에 대해 설명해 주세요.
트랜잭션의 특성인 ACID 원칙은 데이터베이스의 신뢰성을 유지하기 위해 필요합니다.   
먼저 원자성은 트랜잭션 내의 모든 작업이 하나의 단위로 실행되어야 한다는 원칙입니다. 일부만 적용되거나 실패하는 것이 아니라, 모두 성공하거나 모두 실패해야 합니다.   
일관성은 트랜잭션이 실행되기 전과 후의 데이터 상태가 항상 일관되어야야 한다는 의미입니다. 데이터베이스의 규칙을 어기는 변경이 일어나면 트랜잭션이 롤백됩니다.   
그리고 격리성은 여러 트랜잭션이 동시에 실행될 때 서로 영향을 주지 않아야 한다는 원칙입니다. 한 트랜잭션이 진행 중일 때, 다른 트랜잭션이 그 데이터를 변경하지 못하도록 막아야 합니다.   
마지막으로 지속성은 트랜잭션이 성공적으로 완료되면 그 변경 사항이 영구적으로 저장되어야 한다는 원칙입니다. 시스템이 장애가 발생하더라도 완료된 트랜잭션의 데이터는 사라지지 않아야 합니다.   

### Q. 트랜잭션 격리 수준에 대해 설명해주세요. 그리고 왜 필요한가요?
트랜잭션 격리 수준은 동시에 실행되는 여러 트랜잭션 간의 충돌을 방지하고, 데이터의 일관성을 유지하기 위해 설정하는 기준입니다.   
격리 수준이 낮을수록 성능은 좋아지지만, 데이터 정합성이 떨어질 수 있고, 반대로 격리 수준이 높아질수록 데이터 정합성은 보장되지만 성능이 저하될 수 있습니다.   
가장 낮은 수준인 READ UNCOMMITTED는 트랜잭션이 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있도록 허용합니다.    
다음으로 READ COMMITTED는 트랜잭션이 커밋된 데이터만 읽을 수 있도록 보장합니다. 하지만 한 트랜잭션이 같은 데이터를 두 번 조회했을 때 값이 변경될 수 있는 "반복 불가능한 조회" 문제가 발생할 수 있습니다.   
그보다 더 높은 수준인 REPEATABLE READ에서는 하나의 트랜잭션 내에서 동일한 데이터를 여러 번 조회해도 값이 변하지 않습니다. 하지만 새로운 행이 추가될 경우, 이전과 조회 결과가 달라지는 "팬텀 리드" 현상이 발생할 수 있습니다.   
가장 엄격한 격리 수준인 SERIALIZABLE은 모든 트랜잭션을 순차적으로 실행하도록 보장하여 완전한 데이터 정합성을 유지할 수 있습니다. 하지만 동시 처리 성능이 크게 저하될 수 있기 때문에, 성능과 정합성을 고려하여 적절한 수준을 선택해야 합니다.   

### Q. 트랜잭션의 Commit 연산에 대해서 트랜잭션의 상태를 통해 설명해 주세요.
먼저, 트랜잭션이 시작되면 활성 상태가 됩니다. 이 상태에서는 SQL 연산을 수행하며, 아직 데이터베이스에는 반영되지 않은 상태입니다.   
모든 연산이 정상적으로 수행되면 부분 완료 상태가 됩니다.    
이후, COMMIT 명령어가 실행되면 트랜잭션이 완료(Committed) 상태로 변경되며, 모든 변경 사항이 데이터베이스에 영구적으로 저장됩니다.   
반대로 오류가 발생하여 트랜잭션이 중단되면 실패 상태가 되고, ROLLBACK이 실행되면 변경된 모든 사항들이 취소되며 철회(Aborted) 상태가 됩니다.   

### Q. 트랜잭션 사용 시 주의점은?
우선 트랜잭션 범위를 최소화해야 합니다. 트랜잭션이 오래 지속되면 다른 트랜잭션이 대기해야 하는 시간이 길어져 성능 저하가 발생할 수 있습니다.   
또한, 적절한 격리 수준을 선택해야 합니다. 너무 낮은 격리 수준을 사용하면 데이터 정합성이 깨질 위험이 있고, 너무 높은 격리 수준을 사용하면 성능 저하가 발생할 수 있습니다.   
그리고 데드락(Deadlock)을 방지해야 합니다. 여러 트랜잭션이 동일한 자원에 대해 대기하면서 무한 대기 상태가 될 수 있기 때문에, 트랜잭션 수행 순서를 조정하거나 타임아웃을 설정해야 합니다.   
마지막으로 예외 발생 시 반드시 ROLLBACK 처리를 해야 합니다. 트랜잭션이 실패했을 때 ROLLBACK을 수행하지 않으면 데이터가 잘못된 상태로 남아 무결성을 해칠 수 있습니다.   

### Q. ROLLBACK이 실행될 수 없는 경우는 언제인가요?
먼저 트랜잭션이 이미 COMMIT된 경우에는 롤백할 수 없습니다. COMMIT이 실행되면 변경 사항이 데이터베이스에 영구적으로 저장되므로 되돌릴 수 없습니다.   
그리고 DDL 명령어가 실행된 경우에도 롤백이 불가능합니다. 이런 명령어들은 자동으로 COMMIT이 수행되기 때문에 되돌릴 수 없습니다.   
또한, 자동 커밋 모드가 활성화된 경우에도 롤백이 불가능합니다. MySQL과 같은 데이터베이스에서는 기본적으로 AUTO COMMIT이 활성화되어 있어서, ROLLBACK을 실행해도 이미 적용된 변경 사항을 취소할 수 없습니다.   

### Q. 트랜잭션이 실패한 경우 데이터베이스는 어떻게 원래 상태로 되돌아가나요?
트랜잭션이 실패하면 ROLLBACK 연산을 수행하여 모든 변경 사항을 원래 상태로 되돌립니다.   
트랜잭션이 실행될 때 데이터베이스는 변경 내용을 즉시 반영하지 않고 임시 로그에 저장합니다.    
그래서 트랜잭션 도중 오류나 예외 상황이 발생하면, ROLLBACK을 실행하여 트랜잭션이 시작되기 전의 상태로 복구할 수 있습니다.    

